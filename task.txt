## Task Instructions

### Step 1: Project Setup

1. Create a new folder and virtual environment  
2. Install required packages:
   - `flask`
   - `flask_sqlalchemy`
   - `flask_migrate`
   - `python-dotenv`
3. Use SQLite
---

### Step 2: App Factory + Config

- Use an **app factory** to create the Flask app  
- Configure the app with **database URI** and **secret key**  
- Initialize **SQLAlchemy** and **Flask-Migrate**  

---

### Step 3: Models

- Create two models: `Library` and `Book`  
- Define a **one-to-many relationship**: a library can have many books  
- Add relevant fields:
  - `Library`: `id`, `name`  
  - `Book`: `id`, `title`, `author`, `library_id`, `created_at`  

---

### Step 4: CRUD Routes

- Create routes for **libraries**:
  - Create, list, update, delete  
- Create routes for **books**:
  - Create, list, update, delete  
- Use **JSON requests and responses**  

---

### Step 5: Migrations

- Initialize **Flask-Migrate**  
- Create initial migration for the tables  
- Apply migrations to the database  

---

### Step 6: Run the App

- Use a `run.py` file to start the Flask app  
- Test CRUD routes using **Postman**, **curl**, or a browser  

---

### Step 7: Additional Features

- Filter books by library  
- Search books by title or author
- Get all books under a library



















-Create a controller file to implement the logic for creating,  --done
  updating, deleting users — keeps routes simple and makes logic reusable and testable. ---done

-Folder structure: include a routes/ folder, one file per endpoint, --done
  importing functions from the controller — organizes code and separates HTTP handling from business logic. --done

-Path Parameters for Update/Delete: send the resource ID as a path parameter
 —  clearly identifies the resource.

-Keep HTTP status codes in a constants file 
  — improves readability and consistency across the codebase.

-Store sensitive info in environment variables and provide an .env.example ---done
  — keeps secrets safe and makes setup easier for others. ---done

-Handle errors before the database: validate inputs and catch errors at the application level
 — prevents unnecessary database calls and returns cleaner error messages.